#This is not c++ code. Just a memo.

struct bone{ #FMeshBoneInfo in umodel
    uint32: name id (in .uasset) (FNameRef in umodel)
    uint32: instance (null?)
    uint32: parent id (not name id. -1 means null)
}

struct bone_pos{ #FTransform in umodel
    float32*4: rotation (x,y,z,w)
    float32*3: position (x,y,z)
    float32*3: size (x,y,z)
}

struct skeleton{ #FReferenceSkeleton in umodel
    uint32: bone_num
    bone array
    uint32: bone_num
    bone_pos array
    uint32: bone_num
    bone array: NameToIndexMap (parent=self)
}

struct LOD_Section{
    uint16: 1 (StripFlags?)
    uint16: material id
    uint32: (first face's id) * 3  #BaseIndex in umodel
    uint32: face num
    {i don't known about this block well.
        #TriangleSorting byte
        #bDisabled bool4
        #CorrespondClothSectionIndex int16
        #bEnableClothLOD_DEPRECATED byte
        #bRecomputeTangent bool4
        #bCastShadow bool4
        uint32: 0 (TriangleSorting?)
        4-byte: ? (00FFFFCD)
        uint32: 0 (RecomputeTangent?)
        uint32: 1 (CastShadow?)
    }
    uint32: first vertex's id #BaseVertexIndex in umodel
    uint32: array size
    uint16 array: vertex group (BoneMap in umodel)
    uint32: vertex num
    uint32: MaxBoneInfluences
    uint32: Null (ClothingMappingData size)
    uint32: Null (PhysicalMeshVertices size)
    uint32: Null (PhysicalMeshNormals size)
    2-byte: CorrespondClothAssetIndex? (CDCD) 
    uint32*4: Null (GUID in FClothingSectionData)
    uint32: -1 (AssetLodIndex in FClothingSectionData)
    uint32: KDI_flag
    uint32: array size (number of KDI bones)
    16-byte array: KDI bone's weight?
}

struct face{
    uint16: v1
    uint16: v2
    uint16: v3
}

struct LOD_face{
    uint8: int type (2:uint16, otherwise:uint32)
    uint32: stride of IB
    uint32: face_num*3
    face array (IB)
}

struct vertex(uv_num){
    uint8*4: normal (object space?) (-1.0~1.0 -> 0~255)
    uint8*4: normal (tangent space) (-1.0~1.0 -> 0~255)
    float32*3: position (x,y,z)
    for each uv:
        float16*2: position (u,v)
}

struct bone_influences{ x:4 or 8
    uint8*x: vertex group ids (not bone id.)
    uint8*x: weights
}

struct LOD_vertex{
    #FSkeletalMeshVertexBuffer4
    uint16*2: 0,1 #StripFlags
    uint32: uv_num
    uint32: UseFullPrecisionUVs
    float32*3: MeshExtension (1.0, 1.0, 1.0)
    float32*3: MeshOrigin (0,0,0)
    uint32: size of vertex object (20+uv_num*4)
    uint32: array size (vertex_num)
    vertex(uv_num) array
    #FSkinWeightVertexBuffer
    uint16*2: 1,0 StripFlags 
    uint16: 0
    uint32: vertex_num
    uint32: size of bone_influences (8 or 16)
    uint32: array size (vertex_num)
    bone_influences array: bone influences
}

struct LOD{ #FStaticLODModel4 in umodel
    uint16: 1 (StripFlags?)
    uint32: Section's array size
    LOD_Section array
    LOD_face
    uint32: array size
    uint16 array: active bone ids
    uint32: 0
    uint32: vertex_num
    uint32: array size (bone_num)
    uint16 array: required bone ids
    uint32: 0 (MeshToImportVertexMap)
    uint32: 0 (MaxImportVertex)
    uint16: uv_num
    LOD_vertex
    LOD_face: ?

    if KDI_flag{
        #KDI buffer
        uint16: 1
        uint32: stride (16)
        uint32: array size
        16-byte array: KDI bone's weight?

        #vertex buffer for KDI
        uint16: 1
        uint32: stride (4)
        uint32: array size (vertex_num)
        int32 array: Ids of KDI bones
    }
}

struct mesh?{
    uint32: vertex_num
    float32*3 array: vertex position
    uint32: vertex_num
    uint16*4 array: bone ids
    uint8*4: weights ([id1's weight, id2's weight, ...])
    uint32: face_num
    face array
}

struct uexp{
    if has emissive
        2byte: 00 03
        int32: id or something?
        uint32: null
    unknown: ? byte
    FReferenceSkeleton
    uint32: LOD_num
    LOD array
    uint32: 1 (array size?)
    mesh?: same resolution as last LOD
    8 byte: ?
    if has bonamik
        14 byte: bonamik data
    if has kdi
        28 byte: kdi data
    4-byte: unreal signature
}

struct unknown{
    
    bytes:?
    int32: ? (minus value)
    uint32: array size
    11-byte: ?
    array{
        uint32: material_num ?
        material_num*3-byte: 800707*material_num
        
        8-byte: ?
        float32*2: ?
        17-byte:?
        
        if not last{
            8-byte: ?
            float32*(1 or 2): ?
            uint32: array size (material_num?)
            uint32 array: material ids?
        }
    }
    some bytes: ?
    uint32: array size
    uint32 array
    uint32: 0
    uint16 : 1
    float32*7
    uint32:array size
    array {
        int32: ?
        uint32: ?
        uint32*3:0,1,0
        float32*3:?
        uint32: null
    }
}